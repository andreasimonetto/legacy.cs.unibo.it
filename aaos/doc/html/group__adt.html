<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Double A O.S.: Abstract Data Types</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Abstract Data Types</h1><a class="el" href="adt_8h.html" title="Abstract Data Type module.">adt.h</a>: The macros below are sets of template functions and structures that implements specific ADTs.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adt.html#gba4bb0a05e1dd1ea16aae28d434464a7">DEF_ADT_SMM</a>(T, domain, size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static Memory Manager.  <a href="#gba4bb0a05e1dd1ea16aae28d434464a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adt.html#gc2147c5a2fd20b5187461f58a777dcd8">DEF_ADT_QUEUE</a>(T, domain, field_next, field_prev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue.  <a href="#gc2147c5a2fd20b5187461f58a777dcd8"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="adt_8h.html" title="Abstract Data Type module.">adt.h</a>: The macros below are sets of template functions and structures that implements specific ADTs. 
<p>
Because in C doesn't exist the concept of <em>overloading</em>, each function must have a unique name. So, in order to obtain a sort of "template", the functions must be builded changing their name. This is the role of the <em>domain</em> parameter, present in each of these macros.<p>
The parameter <em>T</em> is the real template parameter and stands for "generic type".<p>
Other parameters are ADT-dependent.<p>
Sets of functions are generated without their prototype, that will be written by hand by the programmer, if needed. This permit a better documentation phase, writing what eachs single function do. <hr><h2>Define Documentation</h2>
<a class="anchor" name="gc2147c5a2fd20b5187461f58a777dcd8"></a><!-- doxytag: member="adt.h::DEF_ADT_QUEUE" ref="gc2147c5a2fd20b5187461f58a777dcd8" args="(T, domain, field_next, field_prev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEF_ADT_QUEUE          </td>
          <td>(</td>
          <td class="paramtype">T,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">domain,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">field_next,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">field_prev&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queue. 
<p>
This is a queue ADT implemented with a double-linked, circular, tail-pointed list.<p>
<em>field_next</em> and <em>field_prev</em> parameters are self structure pointers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>The type of the elements to manage. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>domain</em>&nbsp;</td><td>A single word that will be used in the name of the generated functions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>field_next</em>&nbsp;</td><td>The name of the "next element pointer" in the user-defined structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>field_prev</em>&nbsp;</td><td>The name of the "previous element pointer" in the user-defined structure.</td></tr>
  </table>
</dl>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="adt_8h.html" title="Abstract Data Type module.">adt.h</a>&gt;</span>

<span class="comment">/* A user-defined structure. */</span>
<span class="keyword">struct </span>elem {
        <span class="comment">/* field_next and field_prev */</span>
        <span class="keyword">struct </span>elem *ptr_next, *ptr_prev;
        
        <span class="comment">/* Other fields ... */</span>
        <span class="keywordtype">int</span> val;
};

<span class="comment">/* 1. Build an empty queue (i.e. NULL). */</span>
<span class="keyword">struct </span>elem *mkEmptyElementQ();

<span class="comment">/* 2. Test whether or not a Queue is empty. */</span>
<span class="keywordtype">int</span> emptyElementQ(<span class="keyword">const</span> <span class="keyword">struct</span> elem *q);

<span class="comment">/* 3. Enqueue an Element into a Queue. */</span>
<span class="keywordtype">void</span> insertElement(<span class="keyword">struct</span> elem **q, <span class="keyword">struct</span> elem *v);

<span class="comment">/* 4. Remove an Element from a Queue.</span>
<span class="comment">        NOTE: The Element you want to remove must be present in the Queue. This </span>
<span class="comment">        function doesn't search occurrences of v in the queue. The result</span>
<span class="comment">        of removing an Element that's not present in the Queue is unpredictable.</span>
<span class="comment">*/</span>
<span class="keyword">struct </span>elem *outElement(<span class="keyword">struct</span> elem **q, <span class="keyword">struct</span> elem *v);

<span class="comment">/* 5. Extract the outgoing Element from a Queue. */</span>
<span class="keyword">struct </span>elem *removeElement(<span class="keyword">struct</span> elem **q);

<span class="comment">/* 6. Return the outgoing Element. */</span>
<span class="keyword">struct </span>elem *headElement(<span class="keyword">const</span> <span class="keyword">struct</span> elem *q);

<span class="comment">/* 7. Search for Element v in the Queue q. Return v if found, NULL otherwise. */</span>
<span class="keyword">struct </span>elem *searchElement(<span class="keyword">const</span> <span class="keyword">struct</span> elem *q, <span class="keyword">const</span> <span class="keyword">struct</span> elem *v);

<span class="keywordtype">int</span> main() {
        ...
}

<a class="code" href="group__adt.html#gc2147c5a2fd20b5187461f58a777dcd8" title="Queue.">DEF_ADT_QUEUE</a>(<span class="keyword">struct</span> elem, Element, ptr_next, ptr_prev)
</pre></div><p>
After the preprocessing, the body of the functions prototypes from 1 to 7 are present at the bottom of the file. 
</div>
</div><p>
<a class="anchor" name="gba4bb0a05e1dd1ea16aae28d434464a7"></a><!-- doxytag: member="adt.h::DEF_ADT_SMM" ref="gba4bb0a05e1dd1ea16aae28d434464a7" args="(T, domain, size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEF_ADT_SMM          </td>
          <td>(</td>
          <td class="paramtype">T,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">domain,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Static Memory Manager. 
<p>
The Static Memory Manager ADT encapsulate a fixed memory area to store generic elements, and the functions to allocate/deallocate them. An addictional amount <em>C</em> of memory will be allocated when a SMM is instantiated, where:<ul>
<li>C = (size + 1) * sizeof(int)</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>The type of the elements to manage. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>domain</em>&nbsp;</td><td>A single word that will be used in the name of the generated functions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The maximum numbers of elements in the (statically allocated) memory area (size_bytes = sizeof(T) * size).</td></tr>
  </table>
</dl>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="adt_8h.html" title="Abstract Data Type module.">adt.h</a>&gt;</span>
<span class="preprocessor">#define MAX_INFO 100</span>
<span class="preprocessor"></span>        
<span class="keyword">struct </span>info {
        <span class="keywordtype">int</span> id;
        <span class="keywordtype">char</span> details[50];
        <span class="keywordtype">char</span> authors[50];
};

<span class="comment">/* 1. Init the memory area needed. */</span>
<span class="keywordtype">void</span> initInfos();

<span class="comment">/* 2. Free an element previuosly allocated with allocInfo(). */</span>
<span class="keywordtype">void</span> freeInfo(<span class="keyword">struct</span> info *m);

<span class="comment">/* 3. Allocate an element. Return NULL on failure.</span>
<span class="comment">        NOTE: The initial value of the allocated element is unknown.</span>
<span class="comment">*/</span>
<span class="keyword">struct </span>info* allocInfo();
                
<span class="comment">/* 4. Return an identifier for the element. */</span>
<span class="keywordtype">int</span> getInfoID(<span class="keyword">const</span> <span class="keyword">struct</span> info*);

<span class="keywordtype">int</span> main() {
        ...
}

<a class="code" href="group__adt.html#gba4bb0a05e1dd1ea16aae28d434464a7" title="Static Memory Manager.">DEF_ADT_SMM</a>(<span class="keyword">struct</span> info, Info, MAX_INFO) <span class="comment">/* WITHOUT the semicolon!! */</span>
</pre></div><p>
After the preprocessing, the body of the functions prototypes 1, 2, 3 and 4 are present at the bottom of the file.<p>
In the example, if <em>sizeof(int)</em> == 4bytes:<ul>
<li>C = (100 + 1) * 4 = 404byte</li><li>total amount of memory used = (sizeof(struct info) * size) + C = (4+50+50) * 100 + C = 10804bytes </li></ul>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Dec 21 17:21:05 2008 for Double A O.S. by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
