<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Double A O.S.: interface</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>interface</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge25aa2afb1e11b31db30ad6085a89a50"></a><!-- doxytag: member="Kernel::CREATENOGOOD" ref="ge25aa2afb1e11b31db30ad6085a89a50" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Kernel.html#ge25aa2afb1e11b31db30ad6085a89a50">CREATENOGOOD</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicate that thread creation went wrong. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb4f83fc3595f0fdb21f4a7ca5ce58fb6"></a><!-- doxytag: member="Kernel::MSGNOGOOD" ref="gb4f83fc3595f0fdb21f4a7ca5ce58fb6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Kernel.html#gb4f83fc3595f0fdb21f4a7ca5ce58fb6">MSGNOGOOD</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicate that message passing went wrong. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd53eb5b21afa5c70f498ade4c07a857d"></a><!-- doxytag: member="Kernel::SSI_MAGICNO" ref="gd53eb5b21afa5c70f498ade4c07a857d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>SSI_MAGICNO</b>&nbsp;&nbsp;&nbsp;0x0FFFFFFF</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g64862cd049758be4910ae78170276fbe"></a><!-- doxytag: member="Kernel::ANYMESSAGE" ref="g64862cd049758be4910ae78170276fbe" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Kernel.html#g64862cd049758be4910ae78170276fbe">ANYMESSAGE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For receiving messages from any sender. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Kernel.html#g1974bb5cafbaefdc648db97e7ffcc1cb">msg_send</a>(dest, payload)&nbsp;&nbsp;&nbsp;(SYSCALL(SEND, (unsigned)(dest), (unsigned)(payload), 0))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message to a thread.  <a href="#g1974bb5cafbaefdc648db97e7ffcc1cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Kernel.html#g2b4836bdc10d3673bcd9bd9f9fc5bef4">msg_recv</a>(source, reply)&nbsp;&nbsp;&nbsp;(((<a class="el" href="structtcb__t.html">tcb_t</a>*)SYSCALL(RECV, (unsigned)(source), (unsigned)(reply), 0)))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a message from a thread.  <a href="#g2b4836bdc10d3673bcd9bd9f9fc5bef4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Kernel.html#gac232a6efd6fe7eba766fd27c652b5cc">SyscallMsg</a> { <b>SEND</b> =  1, 
<b>RECV</b> =  2
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Syscall mnemonic values. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Kernel.html#g1cbceddebd8723dff49458ce4045853f">ServiceRequest</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__Kernel.html#gg1cbceddebd8723dff49458ce4045853fdc448ce3eefa10077844832a6af19ffa">CREATEBROTHER</a> =  1, 
<a class="el" href="group__Kernel.html#gg1cbceddebd8723dff49458ce4045853f71072182f5e358131f6b9eb659635291">CREATESON</a>, 
<a class="el" href="group__Kernel.html#gg1cbceddebd8723dff49458ce4045853f9aab2d9eae3e9a84d9fed3f0cadd7e22">TERMINATE</a>, 
<a class="el" href="group__Kernel.html#gg1cbceddebd8723dff49458ce4045853ff7d985b96f94d78997dc93747b605c31">SPECPRGMGR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__Kernel.html#gg1cbceddebd8723dff49458ce4045853f94f526c79690438b6c57415636b2885e">SPECTLBMGR</a>, 
<a class="el" href="group__Kernel.html#gg1cbceddebd8723dff49458ce4045853fddb28cb337be3010f1522cf3ef899265">SPECSYSMGR</a>, 
<a class="el" href="group__Kernel.html#gg1cbceddebd8723dff49458ce4045853f1a09fd64037cfe9801ad4f61ccaeca16">GETCPUTIME</a>, 
<a class="el" href="group__Kernel.html#gg1cbceddebd8723dff49458ce4045853fe54320fe119bc3ed036cc9a4635a40d4">WAITFORCLOCK</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__Kernel.html#gg1cbceddebd8723dff49458ce4045853f1e3a5237609db55456ad8b411e3b9f2c">WAITFORIO</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Service request values.  <a href="group__Kernel.html#g1cbceddebd8723dff49458ce4045853f">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__Kernel.html#gg06fc87d81c62e9abb8790b6e5713c55bdef07312c4771960b414a7978d978cef">TRAPTERMINATE</a>, 
<a class="el" href="group__Kernel.html#gg06fc87d81c62e9abb8790b6e5713c55b64b0325ae5a701a1c601d92c357ff52c">TRAPCONTINUE</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commands for the SYSCALL/TLB/TRAP manager.  <a href="group__Kernel.html#g06fc87d81c62e9abb8790b6e5713c55b">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g755e2ed4fdb9bfc9d54c5a28de5a94b6"></a><!-- doxytag: member="Kernel::SSIRequest" ref="g755e2ed4fdb9bfc9d54c5a28de5a94b6" args="(unsigned service, unsigned payload, unsigned *reply)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Kernel.html#g755e2ed4fdb9bfc9d54c5a28de5a94b6">SSIRequest</a> (unsigned service, unsigned payload, unsigned *reply)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a System Service request. <br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="g2b4836bdc10d3673bcd9bd9f9fc5bef4"></a><!-- doxytag: member="kernel.h::msg_recv" ref="g2b4836bdc10d3673bcd9bd9f9fc5bef4" args="(source, reply)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define msg_recv          </td>
          <td>(</td>
          <td class="paramtype">source,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reply&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((<a class="el" href="structtcb__t.html">tcb_t</a>*)SYSCALL(RECV, (unsigned)(source), (unsigned)(reply), 0)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive a message from a thread. 
<p>
<dl class="user" compact><dt><b>source Source thread. ANYMESSAGE for receiving from all threads.</b></dt><dd></dd></dl>
<dl class="user" compact><dt><b>reply Pointer to the reply.</b></dt><dd></dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the TCB of the sender. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1974bb5cafbaefdc648db97e7ffcc1cb"></a><!-- doxytag: member="kernel.h::msg_send" ref="g1974bb5cafbaefdc648db97e7ffcc1cb" args="(dest, payload)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define msg_send          </td>
          <td>(</td>
          <td class="paramtype">dest,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">payload&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(SYSCALL(SEND, (unsigned)(dest), (unsigned)(payload), 0))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a message to a thread. 
<p>
<dl class="user" compact><dt><b>dest Destination thread.</b></dt><dd></dd></dl>
<dl class="user" compact><dt><b>payload Content of the message.</b></dt><dd></dd></dl>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="g06fc87d81c62e9abb8790b6e5713c55b"></a><!-- doxytag: member="kernel.h::@0" ref="g06fc87d81c62e9abb8790b6e5713c55b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Commands for the SYSCALL/TLB/TRAP manager. 
<p>
After the trap handling the manager should send this message to the trapped thread in order to continue it or terminate it. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg06fc87d81c62e9abb8790b6e5713c55bdef07312c4771960b414a7978d978cef"></a><!-- doxytag: member="TRAPTERMINATE" ref="gg06fc87d81c62e9abb8790b6e5713c55bdef07312c4771960b414a7978d978cef" args="" -->TRAPTERMINATE</em>&nbsp;</td><td>
Terminate the trapped thread. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg06fc87d81c62e9abb8790b6e5713c55b64b0325ae5a701a1c601d92c357ff52c"></a><!-- doxytag: member="TRAPCONTINUE" ref="gg06fc87d81c62e9abb8790b6e5713c55b64b0325ae5a701a1c601d92c357ff52c" args="" -->TRAPCONTINUE</em>&nbsp;</td><td>
Continue the trapped thread. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g1cbceddebd8723dff49458ce4045853f"></a><!-- doxytag: member="kernel.h::ServiceRequest" ref="g1cbceddebd8723dff49458ce4045853f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Kernel.html#g1cbceddebd8723dff49458ce4045853f">ServiceRequest</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Service request values. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg1cbceddebd8723dff49458ce4045853fdc448ce3eefa10077844832a6af19ffa"></a><!-- doxytag: member="CREATEBROTHER" ref="gg1cbceddebd8723dff49458ce4045853fdc448ce3eefa10077844832a6af19ffa" args="" -->CREATEBROTHER</em>&nbsp;</td><td>
Create a new thread whose initial processor state is passed by reference as service request payload as brother of the caller. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg1cbceddebd8723dff49458ce4045853f71072182f5e358131f6b9eb659635291"></a><!-- doxytag: member="CREATESON" ref="gg1cbceddebd8723dff49458ce4045853f71072182f5e358131f6b9eb659635291" args="" -->CREATESON</em>&nbsp;</td><td>
Create a new thread whose initial processor state is passed by reference as service request payload as son of the caller. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg1cbceddebd8723dff49458ce4045853f9aab2d9eae3e9a84d9fed3f0cadd7e22"></a><!-- doxytag: member="TERMINATE" ref="gg1cbceddebd8723dff49458ce4045853f9aab2d9eae3e9a84d9fed3f0cadd7e22" args="" -->TERMINATE</em>&nbsp;</td><td>
Terminate the caller thread and all of its progeny in a recursive way. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg1cbceddebd8723dff49458ce4045853ff7d985b96f94d78997dc93747b605c31"></a><!-- doxytag: member="SPECPRGMGR" ref="gg1cbceddebd8723dff49458ce4045853ff7d985b96f94d78997dc93747b605c31" args="" -->SPECPRGMGR</em>&nbsp;</td><td>
This request allows a thread to specify his own trap management thread for Program Trap exceptions. 
<p>
The trap management thread address is passed as service request payload; if the management thread does not exist, the requestor thread and its progeny will be terminated. Once assigned or inherited, the trap management thread cannot be redefined: further service requests of this type will cause the termination of the thread and its progeny. The field reply is not used. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg1cbceddebd8723dff49458ce4045853f94f526c79690438b6c57415636b2885e"></a><!-- doxytag: member="SPECTLBMGR" ref="gg1cbceddebd8723dff49458ce4045853f94f526c79690438b6c57415636b2885e" args="" -->SPECTLBMGR</em>&nbsp;</td><td>
This request allows a thread to specify his own trap management thread for TLB Management exceptions. 
<p>
The trap management thread address is passed as service request payload; if the management thread does not exist, the requestor thread and its progeny will be terminated. Once assigned or inherited, the trap management thread cannot be redefined: further service requests of this type will cause the termination of the thread and its progeny. The field reply is not used. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg1cbceddebd8723dff49458ce4045853fddb28cb337be3010f1522cf3ef899265"></a><!-- doxytag: member="SPECSYSMGR" ref="gg1cbceddebd8723dff49458ce4045853fddb28cb337be3010f1522cf3ef899265" args="" -->SPECSYSMGR</em>&nbsp;</td><td>
This request allows a thread to specify his own trap management thread for SYSCALL/BREAK exceptions. 
<p>
The trap management thread address is passed as service request payload; if the management thread does not exist, the requestor thread and its progeny will be terminated. Once assigned or inherited, the trap management thread cannot be redefined: further service requests of this type will cause the termination of the thread and its progeny. This trap management thread will be called when "pass up" of SYSCALLs and service requests is attempted. The field reply is not used. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg1cbceddebd8723dff49458ce4045853f1a09fd64037cfe9801ad4f61ccaeca16"></a><!-- doxytag: member="GETCPUTIME" ref="gg1cbceddebd8723dff49458ce4045853f1a09fd64037cfe9801ad4f61ccaeca16" args="" -->GETCPUTIME</em>&nbsp;</td><td>
Return the CPU time (in microseconds) used by the requesting thread. 
<p>
The field payload is not used. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg1cbceddebd8723dff49458ce4045853fe54320fe119bc3ed036cc9a4635a40d4"></a><!-- doxytag: member="WAITFORCLOCK" ref="gg1cbceddebd8723dff49458ce4045853fe54320fe119bc3ed036cc9a4635a40d4" args="" -->WAITFORCLOCK</em>&nbsp;</td><td>
The nucleus mantains a pseudo-clock (a pseudo-device which raise an interrupt every 100 milliseconds). 
<p>
Upon request, the requesting thread is blocked until the next pseudo-clock tick. The fields payload and reply are not used. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg1cbceddebd8723dff49458ce4045853f1e3a5237609db55456ad8b411e3b9f2c"></a><!-- doxytag: member="WAITFORIO" ref="gg1cbceddebd8723dff49458ce4045853f1e3a5237609db55456ad8b411e3b9f2c" args="" -->WAITFORIO</em>&nbsp;</td><td>
Block the requesting thread, until the device specified by payload completes its I/O operation. 
<p>
If the device does not exist, the thread and its progeny will be terminated. Return the STATUS register value of the device upon I/O completion. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Mon Jul 2 22:40:19 2007 for Double A O.S. by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
